---
layout: post
title: 알고리즘 기본
subtitle: 분류 및 시간복잡도
date: '2021-03-29 00:01:13 -0400'
background: 'https://source.unsplash.com/category/nature/1600x900'
published: true
---



## 변수형 별 범위


정수형

| 데이터 타입 | 메모리의 크기 | 표현 가능 **범위**                                     |
| :---------- | :------------ | :----------------------------------------------------- |
| short       | 2 byte        | -32,768 ~ 32,767                                       |
| **int**     | 4 byte        | -2,147,483,648~2,147,483,647                           |
| long        | 8 byte        | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |



---


## 시간 복잡도



### 입력 크기별 자주 접하는 시간 복잡도

> 대부분의 문제는 1초의 실행 시간 제한을 가지고 있다. 
> 각 입력의 크기별로 예상할 수 있는 알고리즘의 시간복잡도다.

* O (1) 상수시간 : 

* O (log n)로그시간 

* O( n^(1/2)) 제곱근시간

* O(n) 선형시간 : n <= 10^6

* **O(n log n)** : 효율적인 정렬 알고리즘의 시간 복잡도 : n <= 10^6

* O(n^2) 제곱시간 알고리즘 : n <=5000

* O(n^3) 세제곱 시간 알고리즘: n <= 500

  > 여기까지 다항 시간 알고리즘

* O(2^n)  : n<=20

* O(n!) : n <=10 


---


## 정렬

* 버블정렬 : O(n^2)

* 병합정렬 : O(n log n)

  1. a=b 이면 아무것도 하지 않는다
  2. 가운데 위치 k=(a+b)/2를 계산한다.
  3. a[0-k] ,a[k+1 - b] 를 각각 정렬한다
  4. 취합

``` java
  	public static void merge_sort(int a,int b,int[] arr){
  		if(a==b)return;
  		int k=(a+b)/2;
  		merge_sort(a,k,arr);
  		merge_sort(k+1,b,arr);
  		//System.out.println("시작점 : "+a+ " 끝점 : " + b+ " 중간점 : "+k);
  		merge(a,b,arr);
  		//for(int i:arr)System.out.printf(i+" ");
  		//System.out.println();
  		}
  	private static void merge(int a, int b, int[] arr) {
  		int k=(a+b)/2;
  		int i=a,j=k+1,l=a;
  		int[] temp=new int[arr.length];
  		while(i<=k&&j<=b) {
  			if(arr[i]<arr[j])temp[l++]=arr[i++];
  			else temp[l++]=arr[j++];
  		}
  		while(i<=k) {
  			temp[l++]=arr[i++];
  		}
  		while(j<=b) {
  			temp[l++]=arr[j++];
  		}
  		//System.out.println("중간정렬 결과 : ");
  		//for(int ii:temp)System.out.printf(ii+" ");
  		//System.out.println();
  		for(int m=a;m<=b;m++)arr[m]=temp[m];
  	}

```
  
 * 계수배열 (Counting Sort) : O(n)
  	
    1. 각 데이터의 개수를 count
    2. 누적합을 더해 1부터 최대값까지 누적합(이게 데이터의 새로운 주소가 된다)
    3. 새로운 배열에 누적합의 개수를 -- 해준 후 저장
    
    [참고-얍문님의 설명](https://yabmoons.tistory.com/249)
  
 ```java
	private static void count_sort(int[] arr) {
		int[] cnt=new int[10];
		int[] temp=new int[arr.length];
		for(int i:arr)cnt[i]++;
		for(int i=1;i<10;i++)cnt[i]+=cnt[i-1];
		for(int i=0;i<arr.length;i++) {
			cnt[arr[i]]--;
			temp[cnt[arr[i]]]=arr[i];
			System.out.println("값:"+temp[cnt[arr[i]]]+" 주소:"+cnt[arr[i]]);
		}
		for(int i:temp)System.out.printf(i+" ");
	}

```
  
---
 
  
## Java 에서의 CompareTo,Comparable


Integer.compare(this.a,o.a)
 
 위 함수는 아래와 동일하다
 
 ```java
 public static int compare(int x,int y){
   return (x<y)?-1:((x==y)?0:1)
   //x가 y보다 작다 -1, 같다 0, 크다 
   //즉 오름차순
 }
 ```
 
 x오름차순, x가 같을때 y를 오름 차순으로 정렬(순서 바꾸면 내림차순)
 
 ```java
	@Override
	public int compareTo(node o) {
		if(this.x==o.x) return Integer.compare(this.y,o.y);
		else return Integer.compare(this.x, o.x);
	}

 ```
 return 되는 수가 작을 수록 배열에서 앞쪽
 ``` java
	@Override
	public int compareTo(node o) {
		if(o.x<this.x)return 1;
		else if(o.x==this.x) {
			if(o.y<this.y) {
				return 1;
			}
		}
		return -1;
	}
```


---


## greedy 알고리즘 



[회의실 배정](https://www.acmicpc.net/problem/1931)
> compare 을 쓸때 꼼꼼하게 모든 케이스를 계산하지 않으면 **illegalArgument** 생김 주의!

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;


public class Main1931 {
	static class time implements Comparable<time>{
		long start;
		long end;
		public time(long start, long end) {
			super();
			this.start = start;
			this.end = end;
		}
		@Override
		public int compareTo(time o) {
			if(this.end==o.end) {
				return Long.compare(this.start, o.start);
			}else {
				return Long.compare(this.end, o.end);
			}
		}
		
	}
	public static void main(String[] args) throws Exception {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int n=Integer.parseInt(br.readLine().trim());
		time[] timetable=new time[n];
		for(int i=0;i<n;i++) {
			StringTokenizer st=new StringTokenizer(br.readLine());
			long start=Long.parseLong(st.nextToken());
			long end=Long.parseLong(st.nextToken());
			timetable[i]=new time(start, end);
		}
		Arrays.sort(timetable);
		int cnt=1;
		long now=timetable[0].end;
		for(int i=1;i<n;i++) {
			if(now<=timetable[i].start) {
				now=timetable[i].end;
				cnt++;
			}
		}
		System.out.println(cnt);
	}
}

```
> end 시간 오름차순 end 가 같을때 start 시간 오름차순으로 정리한다. (문제 조건에는 없지만, 시작시간과 끝 시간이 같을 수 있기 때문이다.)

>> 반례 ) (3,3),(2,3),(3,3) 일때 최적은 3 이지만, 시작시간의 오름차순으로 정리되지 않으면 2가 나옴

[예외케이스가 잘 정리 된 블로그](https://lmcoa15.tistory.com/39)

[최소 회의실 개수](https://www.acmicpc.net/problem/19598)


---

# 이분 탐색

[나무자르기](https://www.acmicpc.net/problem/2805)

```java
import java.util.Scanner;

public class Main2805 {
	static long high;
	static int n;
	static long m;
	static long[] tree;
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		n=sc.nextInt();
		m=sc.nextLong();
		tree=new long[n];
		long max=0;
		for(int i=0;i<n;i++) {
			tree[i]=sc.nextLong();
			max=Math.max(max, tree[i]);
		}
		high=0;
		solv(0,max);
		System.out.println(high);
	}
	private static void solv(long start, long end) {
		//System.out.println(start+" "+end);
		if(start>=end)return;
		long mid=(start+end)/2;
		long sum=0;
		for(int i=0;i<n;i++) {
			sum+=Math.max(tree[i]-mid, 0);
		}
		
		if(sum<m) {
			solv(start,mid);
		}else {	
			high=Math.max(high, mid);//적어도 m의 나무를 (글자를 잘 읽자)
			solv(mid+1,end);
		}
	}

}
```

[수 찾기](https://www.acmicpc.net/problem/1920)

> 띄엄 띄엄 보는 이분탐색 
m/2씩 보다가 못찾으면 m/4씩 탐색 이걸 m/(2^n)==1 일때까지 반복

```java

package Pro;

import java.util.Arrays;
import java.util.Scanner;

public class Main1920 {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int m=sc.nextInt();
		int[] num=new int[m];
		for(int i=0;i<m;i++) {
			num[i]=sc.nextInt();
		}
		int n=sc.nextInt();
		int[] search=new int[n];
		for(int i=0;i<n;i++) {
			search[i]=sc.nextInt();
		}
		Arrays.sort(num);
		for(int i=0;i<n;i++) {
			//System.out.printf(search[i]+" ");
			int idx=0;
			for(int add=m/2;add>=1;add/=2) {
				//System.out.printf("! ");
				while(idx+add<m&&search[i]>=num[idx+add]) {
					idx+=add;
					//System.out.printf("?? "+idx+" ");
				}
			}
			if(num[idx]==search[i])System.out.println(1);
			else System.out.println(0);
		}
	}

}

```

[합이 0 인 네 정수](https://www.acmicpc.net/problem/7453)

---

# 다이나믹 프로그래밍(Dynamic Programming)

<details>
  
  <summary>
    기본
  </summary>
  
  	[포도주 시식](https://www.acmicpc.net/problem/2156)
  
```java
  package Pro;

import java.util.Arrays;
import java.util.Scanner;

public class Main1920 {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int m=sc.nextInt();
		int[] num=new int[m];
		for(int i=0;i<m;i++) {
			num[i]=sc.nextInt();
		}
		int n=sc.nextInt();
		int[] search=new int[n];
		for(int i=0;i<n;i++) {
			search[i]=sc.nextInt();
		}
		Arrays.sort(num);
		for(int i=0;i<n;i++) {
			//System.out.printf(search[i]+" ");
			int idx=0;
			for(int add=m/2;add>=1;add/=2) {
				//System.out.printf("! ");
				while(idx+add<m&&search[i]>=num[idx+add]) {
					idx+=add;
					//System.out.printf("?? "+idx+" ");
				}
			}
			if(num[idx]==search[i])System.out.println(1);
			else System.out.println(0);
		}
	}

}
                           
```

</details>
  

* 최장 증가 부분 수열(LIS)
[가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)
[가장 큰 증가 부분 수열](https://www.acmicpc.net/problem/11055)
[LCS2](https://www.acmicpc.net/problem/9252)

* 짐 싸기 문제 (knapsack)
[평범한 배낭](https://www.acmicpc.net/problem/12865)

* 타일 세기
[타일 채우기](https://www.acmicpc.net/problem/2718)

* 기타
[회의실 배정2](https://www.acmicpc.net/problem/19621)
[회의실 배정3](https://www.acmicpc.net/problem/19622)
[회의실 배정4](https://www.acmicpc.net/problem/19623)
[가장 큰 정사각형](https://www.acmicpc.net/problem/1915)
